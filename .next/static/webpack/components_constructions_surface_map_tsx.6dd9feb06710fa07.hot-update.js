/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("components_constructions_surface_map_tsx",{

/***/ "./node_modules/leaflet-kml/L.KML.js":
/*!*******************************************!*\
  !*** ./node_modules/leaflet-kml/L.KML.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*!\n\tCopyright (c) 2011-2015, Pavel Shramov, Bruno Bergot - MIT licence\n*/\n\nL.KML = L.FeatureGroup.extend({\n\n\tinitialize: function (kml) {\n\t\tthis._kml = kml;\n\t\tthis._layers = {};\n\n\t\tif (kml) {\n\t\t\tthis.addKML(kml);\n\t\t}\n\t},\n\n\taddKML: function (xml) {\n\t\tvar layers = L.KML.parseKML(xml);\n\t\tif (!layers || !layers.length) return;\n\t\tfor (var i = 0; i < layers.length; i++) {\n\t\t\tthis.fire('addlayer', {\n\t\t\t\tlayer: layers[i]\n\t\t\t});\n\t\t\tthis.addLayer(layers[i]);\n\t\t}\n\t\tthis.latLngs = L.KML.getLatLngs(xml);\n\t\tthis.fire('loaded');\n\t},\n\n\tlatLngs: []\n});\n\nL.Util.extend(L.KML, {\n\n\tparseKML: function (xml) {\n\t\tvar style = this.parseStyles(xml);\n\t\tthis.parseStyleMap(xml, style);\n\t\tvar el = xml.getElementsByTagName('Folder');\n\t\tvar layers = [], l;\n\t\tfor (var i = 0; i < el.length; i++) {\n\t\t\tif (!this._check_folder(el[i])) { continue; }\n\t\t\tl = this.parseFolder(el[i], style);\n\t\t\tif (l) { layers.push(l); }\n\t\t}\n\t\tel = xml.getElementsByTagName('Placemark');\n\t\tfor (var j = 0; j < el.length; j++) {\n\t\t\tif (!this._check_folder(el[j])) { continue; }\n\t\t\tl = this.parsePlacemark(el[j], xml, style);\n\t\t\tif (l) { layers.push(l); }\n\t\t}\n\t\tel = xml.getElementsByTagName('GroundOverlay');\n\t\tfor (var k = 0; k < el.length; k++) {\n\t\t\tl = this.parseGroundOverlay(el[k]);\n\t\t\tif (l) { layers.push(l); }\n\t\t}\n\t\treturn layers;\n\t},\n\n\t// Return false if e's first parent Folder is not [folder]\n\t// - returns true if no parent Folders\n\t_check_folder: function (e, folder) {\n\t\te = e.parentNode;\n\t\twhile (e && e.tagName !== 'Folder')\n\t\t{\n\t\t\te = e.parentNode;\n\t\t}\n\t\treturn !e || e === folder;\n\t},\n\n\tparseStyles: function (xml) {\n\t\tvar styles = {};\n\t\tvar sl = xml.getElementsByTagName('Style');\n\t\tfor (var i=0, len=sl.length; i<len; i++) {\n\t\t\tvar style = this.parseStyle(sl[i]);\n\t\t\tif (style) {\n\t\t\t\tvar styleName = '#' + style.id;\n\t\t\t\tstyles[styleName] = style;\n\t\t\t}\n\t\t}\n\t\treturn styles;\n\t},\n\n\tparseStyle: function (xml) {\n\t\tvar style = {}, poptions = {}, ioptions = {}, el, id;\n\n\t\tvar attributes = {color: true, width: true, Icon: true, href: true, hotSpot: true};\n\n\t\tfunction _parse (xml) {\n\t\t\tvar options = {};\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\t\t\t\tvar e = xml.childNodes[i];\n\t\t\t\tvar key = e.tagName;\n\t\t\t\tif (!attributes[key]) { continue; }\n\t\t\t\tif (key === 'hotSpot')\n\t\t\t\t{\n\t\t\t\t\tfor (var j = 0; j < e.attributes.length; j++) {\n\t\t\t\t\t\toptions[e.attributes[j].name] = e.attributes[j].nodeValue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar value = e.childNodes[0].nodeValue;\n\t\t\t\t\tif (key === 'color') {\n\t\t\t\t\t\toptions.opacity = parseInt(value.substring(0, 2), 16) / 255.0;\n\t\t\t\t\t\toptions.color = '#' + value.substring(6, 8) + value.substring(4, 6) + value.substring(2, 4);\n\t\t\t\t\t} else if (key === 'width') {\n\t\t\t\t\t\toptions.weight = value;\n\t\t\t\t\t} else if (key === 'Icon') {\n\t\t\t\t\t\tioptions = _parse(e);\n\t\t\t\t\t\tif (ioptions.href) { options.href = ioptions.href; }\n\t\t\t\t\t} else if (key === 'href') {\n\t\t\t\t\t\toptions.href = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn options;\n\t\t}\n\n\t\tel = xml.getElementsByTagName('LineStyle');\n\t\tif (el && el[0]) { style = _parse(el[0]); }\n\t\tel = xml.getElementsByTagName('PolyStyle');\n\t\tif (el && el[0]) { poptions = _parse(el[0]); }\n\t\tif (poptions.color) { style.fillColor = poptions.color; }\n\t\tif (poptions.opacity) { style.fillOpacity = poptions.opacity; }\n\t\tel = xml.getElementsByTagName('IconStyle');\n\t\tif (el && el[0]) { ioptions = _parse(el[0]); }\n\t\tif (ioptions.href) {\n\t\t\tstyle.icon = new L.KMLIcon({\n\t\t\t\ticonUrl: ioptions.href,\n\t\t\t\tshadowUrl: null,\n\t\t\t\tanchorRef: {x: ioptions.x, y: ioptions.y},\n\t\t\t\tanchorType:\t{x: ioptions.xunits, y: ioptions.yunits}\n\t\t\t});\n\t\t}\n\n\t\tid = xml.getAttribute('id');\n\t\tif (id && style) {\n\t\t\tstyle.id = id;\n\t\t}\n\n\t\treturn style;\n\t},\n\n\tparseStyleMap: function (xml, existingStyles) {\n\t\tvar sl = xml.getElementsByTagName('StyleMap');\n\n\t\tfor (var i = 0; i < sl.length; i++) {\n\t\t\tvar e = sl[i], el;\n\t\t\tvar smKey, smStyleUrl;\n\n\t\t\tel = e.getElementsByTagName('key');\n\t\t\tif (el && el[0]) { smKey = el[0].textContent; }\n\t\t\tel = e.getElementsByTagName('styleUrl');\n\t\t\tif (el && el[0]) { smStyleUrl = el[0].textContent; }\n\n\t\t\tif (smKey === 'normal')\n\t\t\t{\n\t\t\t\texistingStyles['#' + e.getAttribute('id')] = existingStyles[smStyleUrl];\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t},\n\n\tparseFolder: function (xml, style) {\n\t\tvar el, layers = [], l;\n\t\tel = xml.getElementsByTagName('Folder');\n\t\tfor (var i = 0; i < el.length; i++) {\n\t\t\tif (!this._check_folder(el[i], xml)) { continue; }\n\t\t\tl = this.parseFolder(el[i], style);\n\t\t\tif (l) { layers.push(l); }\n\t\t}\n\t\tel = xml.getElementsByTagName('Placemark');\n\t\tfor (var j = 0; j < el.length; j++) {\n\t\t\tif (!this._check_folder(el[j], xml)) { continue; }\n\t\t\tl = this.parsePlacemark(el[j], xml, style);\n\t\t\tif (l) { layers.push(l); }\n\t\t}\n\t\tel = xml.getElementsByTagName('GroundOverlay');\n\t\tfor (var k = 0; k < el.length; k++) {\n\t\t\tif (!this._check_folder(el[k], xml)) { continue; }\n\t\t\tl = this.parseGroundOverlay(el[k]);\n\t\t\tif (l) { layers.push(l); }\n\t\t}\n\t\tif (!layers.length) { return; }\n\t\tif (layers.length === 1) { return layers[0]; }\n\t\treturn new L.FeatureGroup(layers);\n\t},\n\n\tparsePlacemark: function (place, xml, style, options) {\n\t\tvar h, i, j, k, el, il, opts = options || {};\n\n\t\tel = place.getElementsByTagName('styleUrl');\n\t\tfor (i = 0; i < el.length; i++) {\n\t\t\tvar url = el[i].childNodes[0].nodeValue;\n\t\t\tfor (var a in style[url]) {\n\t\t\t\topts[a] = style[url][a];\n\t\t\t}\n\t\t}\n\n\t\til = place.getElementsByTagName('Style')[0];\n\t\tif (il) {\n\t\t\tvar inlineStyle = this.parseStyle(place);\n\t\t\tif (inlineStyle) {\n\t\t\t\tfor (k in inlineStyle) {\n\t\t\t\t\topts[k] = inlineStyle[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar multi = ['MultiGeometry', 'MultiTrack', 'gx:MultiTrack'];\n\t\tfor (h in multi) {\n\t\t\tel = place.getElementsByTagName(multi[h]);\n\t\t\tfor (i = 0; i < el.length; i++) {\n\t\t\t\treturn this.parsePlacemark(el[i], xml, style, opts);\n\t\t\t}\n\t\t}\n\n\t\tvar layers = [];\n\n\t\tvar parse = ['LineString', 'Polygon', 'Point', 'Track', 'gx:Track'];\n\t\tfor (j in parse) {\n\t\t\tvar tag = parse[j];\n\t\t\tel = place.getElementsByTagName(tag);\n\t\t\tfor (i = 0; i < el.length; i++) {\n\t\t\t\tvar l = this['parse' + tag.replace(/gx:/, '')](el[i], xml, opts);\n\t\t\t\tif (l) { layers.push(l); }\n\t\t\t}\n\t\t}\n\n\t\tif (!layers.length) {\n\t\t\treturn;\n\t\t}\n\t\tvar layer = layers[0];\n\t\tif (layers.length > 1) {\n\t\t\tlayer = new L.FeatureGroup(layers);\n\t\t}\n\n\t\tvar name, descr = '';\n\t\tel = place.getElementsByTagName('name');\n\t\tif (el.length && el[0].childNodes.length) {\n\t\t\tname = el[0].childNodes[0].nodeValue;\n\t\t}\n\t\tel = place.getElementsByTagName('description');\n\t\tfor (i = 0; i < el.length; i++) {\n\t\t\tfor (j = 0; j < el[i].childNodes.length; j++) {\n\t\t\t\tdescr = descr + el[i].childNodes[j].nodeValue;\n\t\t\t}\n\t\t}\n\n\t\tif (name) {\n\t\t\tlayer.on('add', function () {\n\t\t\t\tlayer.bindPopup('<h2>' + name + '</h2>' + descr, { className: 'kml-popup'});\n\t\t\t});\n\t\t}\n\n\t\treturn layer;\n\t},\n\n\tparseCoords: function (xml) {\n\t\tvar el = xml.getElementsByTagName('coordinates');\n\t\treturn this._read_coords(el[0]);\n\t},\n\n\tparseLineString: function (line, xml, options) {\n\t\tvar coords = this.parseCoords(line);\n\t\tif (!coords.length) { return; }\n\t\treturn new L.Polyline(coords, options);\n\t},\n\n\tparseTrack: function (line, xml, options) {\n\t\tvar el = xml.getElementsByTagName('gx:coord');\n\t\tif (el.length === 0) { el = xml.getElementsByTagName('coord'); }\n\t\tvar coords = [];\n\t\tfor (var j = 0; j < el.length; j++) {\n\t\t\tcoords = coords.concat(this._read_gxcoords(el[j]));\n\t\t}\n\t\tif (!coords.length) { return; }\n\t\treturn new L.Polyline(coords, options);\n\t},\n\n\tparsePoint: function (line, xml, options) {\n\t\tvar el = line.getElementsByTagName('coordinates');\n\t\tif (!el.length) {\n\t\t\treturn;\n\t\t}\n\t\tvar ll = el[0].childNodes[0].nodeValue.split(',');\n\t\treturn new L.KMLMarker(new L.LatLng(ll[1], ll[0]), options);\n\t},\n\n\tparsePolygon: function (line, xml, options) {\n\t\tvar el, polys = [], inner = [], i, coords;\n\t\tel = line.getElementsByTagName('outerBoundaryIs');\n\t\tfor (i = 0; i < el.length; i++) {\n\t\t\tcoords = this.parseCoords(el[i]);\n\t\t\tif (coords) {\n\t\t\t\tpolys.push(coords);\n\t\t\t}\n\t\t}\n\t\tel = line.getElementsByTagName('innerBoundaryIs');\n\t\tfor (i = 0; i < el.length; i++) {\n\t\t\tcoords = this.parseCoords(el[i]);\n\t\t\tif (coords) {\n\t\t\t\tinner.push(coords);\n\t\t\t}\n\t\t}\n\t\tif (!polys.length) {\n\t\t\treturn;\n\t\t}\n\t\tif (options.fillColor) {\n\t\t\toptions.fill = true;\n\t\t}\n\t\tif (polys.length === 1) {\n\t\t\treturn new L.Polygon(polys.concat(inner), options);\n\t\t}\n\t\treturn new L.MultiPolygon(polys, options);\n\t},\n\n\tgetLatLngs: function (xml) {\n\t\tvar el = xml.getElementsByTagName('coordinates');\n\t\tvar coords = [];\n\t\tfor (var j = 0; j < el.length; j++) {\n\t\t\t// text might span many childNodes\n\t\t\tcoords = coords.concat(this._read_coords(el[j]));\n\t\t}\n\t\treturn coords;\n\t},\n\n\t_read_coords: function (el) {\n\t\tvar text = '', coords = [], i;\n\t\tfor (i = 0; i < el.childNodes.length; i++) {\n\t\t\ttext = text + el.childNodes[i].nodeValue;\n\t\t}\n\t\ttext = text.split(/[\\s\\n]+/);\n\t\tfor (i = 0; i < text.length; i++) {\n\t\t\tvar ll = text[i].split(',');\n\t\t\tif (ll.length < 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcoords.push(new L.LatLng(ll[1], ll[0]));\n\t\t}\n\t\treturn coords;\n\t},\n\n\t_read_gxcoords: function (el) {\n\t\tvar text = '', coords = [];\n\t\ttext = el.firstChild.nodeValue.split(' ');\n\t\tcoords.push(new L.LatLng(text[1], text[0]));\n\t\treturn coords;\n\t},\n\n\tparseGroundOverlay: function (xml) {\n\t\tvar latlonbox = xml.getElementsByTagName('LatLonBox')[0];\n\t\tvar bounds = new L.LatLngBounds(\n\t\t\t[\n\t\t\t\tlatlonbox.getElementsByTagName('south')[0].childNodes[0].nodeValue,\n\t\t\t\tlatlonbox.getElementsByTagName('west')[0].childNodes[0].nodeValue\n\t\t\t],\n\t\t\t[\n\t\t\t\tlatlonbox.getElementsByTagName('north')[0].childNodes[0].nodeValue,\n\t\t\t\tlatlonbox.getElementsByTagName('east')[0].childNodes[0].nodeValue\n\t\t\t]\n\t\t);\n\t\tvar attributes = {Icon: true, href: true, color: true};\n\t\tfunction _parse (xml) {\n\t\t\tvar options = {}, ioptions = {};\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\t\t\t\tvar e = xml.childNodes[i];\n\t\t\t\tvar key = e.tagName;\n\t\t\t\tif (!attributes[key]) { continue; }\n\t\t\t\tvar value = e.childNodes[0].nodeValue;\n\t\t\t\tif (key === 'Icon') {\n\t\t\t\t\tioptions = _parse(e);\n\t\t\t\t\tif (ioptions.href) { options.href = ioptions.href; }\n\t\t\t\t} else if (key === 'href') {\n\t\t\t\t\toptions.href = value;\n\t\t\t\t} else if (key === 'color') {\n\t\t\t\t\toptions.opacity = parseInt(value.substring(0, 2), 16) / 255.0;\n\t\t\t\t\toptions.color = '#' + value.substring(6, 8) + value.substring(4, 6) + value.substring(2, 4);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn options;\n\t\t}\n\t\tvar options = {};\n\t\toptions = _parse(xml);\n\t\tif (latlonbox.getElementsByTagName('rotation')[0] !== undefined) {\n\t\t\tvar rotation = latlonbox.getElementsByTagName('rotation')[0].childNodes[0].nodeValue;\n\t\t\toptions.rotation = parseFloat(rotation);\n\t\t}\n\t\treturn new L.RotatedImageOverlay(options.href, bounds, {opacity: options.opacity, angle: options.rotation});\n\t}\n\n});\n\nL.KMLIcon = L.Icon.extend({\n\toptions: {\n\t\ticonSize: [32, 32],\n\t\ticonAnchor: [16, 16],\n\t},\n\t_setIconStyles: function (img, name) {\n\t\tL.Icon.prototype._setIconStyles.apply(this, [img, name]);\n\t\tif( img.complete ) {\n\t\t\tthis.applyCustomStyles( img )\n\t\t} else {\n\t\t\timg.onload = this.applyCustomStyles.bind(this,img)\n\t\t}\n\n\t},\n\tapplyCustomStyles: function(img) {\n\t\tvar options = this.options;\n\t\tthis.options.popupAnchor = [0,(-0.83*img.height)];\n\t\tif (options.anchorType.x === 'fraction')\n\t\t\timg.style.marginLeft = (-options.anchorRef.x * img.width) + 'px';\n\t\tif (options.anchorType.y === 'fraction')\n\t\t\timg.style.marginTop  = ((-(1 - options.anchorRef.y) * img.height) + 1) + 'px';\n\t\tif (options.anchorType.x === 'pixels')\n\t\t\timg.style.marginLeft = (-options.anchorRef.x) + 'px';\n\t\tif (options.anchorType.y === 'pixels')\n\t\t\timg.style.marginTop  = (options.anchorRef.y - img.height + 1) + 'px';\n\t}\n});\n\n\nL.KMLMarker = L.Marker.extend({\n\toptions: {\n\t\ticon: new L.KMLIcon.Default()\n\t}\n});\n\n// Inspired by https://github.com/bbecquet/Leaflet.PolylineDecorator/tree/master/src\nL.RotatedImageOverlay = L.ImageOverlay.extend({\n\toptions: {\n\t\tangle: 0\n\t},\n\t_reset: function () {\n\t\tL.ImageOverlay.prototype._reset.call(this);\n\t\tthis._rotate();\n\t},\n\t_animateZoom: function (e) {\n\t\tL.ImageOverlay.prototype._animateZoom.call(this, e);\n\t\tthis._rotate();\n\t},\n\t_rotate: function () {\n        if (L.DomUtil.TRANSFORM) {\n            // use the CSS transform rule if available\n            this._image.style[L.DomUtil.TRANSFORM] += ' rotate(' + this.options.angle + 'deg)';\n        } else if (L.Browser.ie) {\n            // fallback for IE6, IE7, IE8\n            var rad = this.options.angle * (Math.PI / 180),\n                costheta = Math.cos(rad),\n                sintheta = Math.sin(rad);\n            this._image.style.filter += ' progid:DXImageTransform.Microsoft.Matrix(sizingMethod=\\'auto expand\\', M11=' +\n                costheta + ', M12=' + (-sintheta) + ', M21=' + sintheta + ', M22=' + costheta + ')';\n        }\n\t},\n\tgetBounds: function () {\n\t\treturn this._bounds;\n\t}\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGVhZmxldC1rbWwvTC5LTUwuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQyxxQ0FBcUM7QUFDckM7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDLHFDQUFxQztBQUNyQztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxnQkFBZ0IsZUFBZSxlQUFlOztBQUU5QyxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLDJCQUEyQjtBQUMzQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUI7QUFDQSxxQkFBcUI7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGVhZmxldC1rbWwvTC5LTUwuanM/YTdiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcblx0Q29weXJpZ2h0IChjKSAyMDExLTIwMTUsIFBhdmVsIFNocmFtb3YsIEJydW5vIEJlcmdvdCAtIE1JVCBsaWNlbmNlXG4qL1xuXG5MLktNTCA9IEwuRmVhdHVyZUdyb3VwLmV4dGVuZCh7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGttbCkge1xuXHRcdHRoaXMuX2ttbCA9IGttbDtcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcblxuXHRcdGlmIChrbWwpIHtcblx0XHRcdHRoaXMuYWRkS01MKGttbCk7XG5cdFx0fVxuXHR9LFxuXG5cdGFkZEtNTDogZnVuY3Rpb24gKHhtbCkge1xuXHRcdHZhciBsYXllcnMgPSBMLktNTC5wYXJzZUtNTCh4bWwpO1xuXHRcdGlmICghbGF5ZXJzIHx8ICFsYXllcnMubGVuZ3RoKSByZXR1cm47XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuZmlyZSgnYWRkbGF5ZXInLCB7XG5cdFx0XHRcdGxheWVyOiBsYXllcnNbaV1cblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuXHRcdH1cblx0XHR0aGlzLmxhdExuZ3MgPSBMLktNTC5nZXRMYXRMbmdzKHhtbCk7XG5cdFx0dGhpcy5maXJlKCdsb2FkZWQnKTtcblx0fSxcblxuXHRsYXRMbmdzOiBbXVxufSk7XG5cbkwuVXRpbC5leHRlbmQoTC5LTUwsIHtcblxuXHRwYXJzZUtNTDogZnVuY3Rpb24gKHhtbCkge1xuXHRcdHZhciBzdHlsZSA9IHRoaXMucGFyc2VTdHlsZXMoeG1sKTtcblx0XHR0aGlzLnBhcnNlU3R5bGVNYXAoeG1sLCBzdHlsZSk7XG5cdFx0dmFyIGVsID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdGb2xkZXInKTtcblx0XHR2YXIgbGF5ZXJzID0gW10sIGw7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbC5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKCF0aGlzLl9jaGVja19mb2xkZXIoZWxbaV0pKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRsID0gdGhpcy5wYXJzZUZvbGRlcihlbFtpXSwgc3R5bGUpO1xuXHRcdFx0aWYgKGwpIHsgbGF5ZXJzLnB1c2gobCk7IH1cblx0XHR9XG5cdFx0ZWwgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1BsYWNlbWFyaycpO1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgZWwubGVuZ3RoOyBqKyspIHtcblx0XHRcdGlmICghdGhpcy5fY2hlY2tfZm9sZGVyKGVsW2pdKSkgeyBjb250aW51ZTsgfVxuXHRcdFx0bCA9IHRoaXMucGFyc2VQbGFjZW1hcmsoZWxbal0sIHhtbCwgc3R5bGUpO1xuXHRcdFx0aWYgKGwpIHsgbGF5ZXJzLnB1c2gobCk7IH1cblx0XHR9XG5cdFx0ZWwgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0dyb3VuZE92ZXJsYXknKTtcblx0XHRmb3IgKHZhciBrID0gMDsgayA8IGVsLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRsID0gdGhpcy5wYXJzZUdyb3VuZE92ZXJsYXkoZWxba10pO1xuXHRcdFx0aWYgKGwpIHsgbGF5ZXJzLnB1c2gobCk7IH1cblx0XHR9XG5cdFx0cmV0dXJuIGxheWVycztcblx0fSxcblxuXHQvLyBSZXR1cm4gZmFsc2UgaWYgZSdzIGZpcnN0IHBhcmVudCBGb2xkZXIgaXMgbm90IFtmb2xkZXJdXG5cdC8vIC0gcmV0dXJucyB0cnVlIGlmIG5vIHBhcmVudCBGb2xkZXJzXG5cdF9jaGVja19mb2xkZXI6IGZ1bmN0aW9uIChlLCBmb2xkZXIpIHtcblx0XHRlID0gZS5wYXJlbnROb2RlO1xuXHRcdHdoaWxlIChlICYmIGUudGFnTmFtZSAhPT0gJ0ZvbGRlcicpXG5cdFx0e1xuXHRcdFx0ZSA9IGUucGFyZW50Tm9kZTtcblx0XHR9XG5cdFx0cmV0dXJuICFlIHx8IGUgPT09IGZvbGRlcjtcblx0fSxcblxuXHRwYXJzZVN0eWxlczogZnVuY3Rpb24gKHhtbCkge1xuXHRcdHZhciBzdHlsZXMgPSB7fTtcblx0XHR2YXIgc2wgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1N0eWxlJyk7XG5cdFx0Zm9yICh2YXIgaT0wLCBsZW49c2wubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSB0aGlzLnBhcnNlU3R5bGUoc2xbaV0pO1xuXHRcdFx0aWYgKHN0eWxlKSB7XG5cdFx0XHRcdHZhciBzdHlsZU5hbWUgPSAnIycgKyBzdHlsZS5pZDtcblx0XHRcdFx0c3R5bGVzW3N0eWxlTmFtZV0gPSBzdHlsZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHN0eWxlcztcblx0fSxcblxuXHRwYXJzZVN0eWxlOiBmdW5jdGlvbiAoeG1sKSB7XG5cdFx0dmFyIHN0eWxlID0ge30sIHBvcHRpb25zID0ge30sIGlvcHRpb25zID0ge30sIGVsLCBpZDtcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0ge2NvbG9yOiB0cnVlLCB3aWR0aDogdHJ1ZSwgSWNvbjogdHJ1ZSwgaHJlZjogdHJ1ZSwgaG90U3BvdDogdHJ1ZX07XG5cblx0XHRmdW5jdGlvbiBfcGFyc2UgKHhtbCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB7fTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGUgPSB4bWwuY2hpbGROb2Rlc1tpXTtcblx0XHRcdFx0dmFyIGtleSA9IGUudGFnTmFtZTtcblx0XHRcdFx0aWYgKCFhdHRyaWJ1dGVzW2tleV0pIHsgY29udGludWU7IH1cblx0XHRcdFx0aWYgKGtleSA9PT0gJ2hvdFNwb3QnKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBlLmF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdG9wdGlvbnNbZS5hdHRyaWJ1dGVzW2pdLm5hbWVdID0gZS5hdHRyaWJ1dGVzW2pdLm5vZGVWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gZS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZTtcblx0XHRcdFx0XHRpZiAoa2V5ID09PSAnY29sb3InKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25zLm9wYWNpdHkgPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoMCwgMiksIDE2KSAvIDI1NS4wO1xuXHRcdFx0XHRcdFx0b3B0aW9ucy5jb2xvciA9ICcjJyArIHZhbHVlLnN1YnN0cmluZyg2LCA4KSArIHZhbHVlLnN1YnN0cmluZyg0LCA2KSArIHZhbHVlLnN1YnN0cmluZygyLCA0KTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3dpZHRoJykge1xuXHRcdFx0XHRcdFx0b3B0aW9ucy53ZWlnaHQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ0ljb24nKSB7XG5cdFx0XHRcdFx0XHRpb3B0aW9ucyA9IF9wYXJzZShlKTtcblx0XHRcdFx0XHRcdGlmIChpb3B0aW9ucy5ocmVmKSB7IG9wdGlvbnMuaHJlZiA9IGlvcHRpb25zLmhyZWY7IH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ2hyZWYnKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25zLmhyZWYgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvcHRpb25zO1xuXHRcdH1cblxuXHRcdGVsID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdMaW5lU3R5bGUnKTtcblx0XHRpZiAoZWwgJiYgZWxbMF0pIHsgc3R5bGUgPSBfcGFyc2UoZWxbMF0pOyB9XG5cdFx0ZWwgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1BvbHlTdHlsZScpO1xuXHRcdGlmIChlbCAmJiBlbFswXSkgeyBwb3B0aW9ucyA9IF9wYXJzZShlbFswXSk7IH1cblx0XHRpZiAocG9wdGlvbnMuY29sb3IpIHsgc3R5bGUuZmlsbENvbG9yID0gcG9wdGlvbnMuY29sb3I7IH1cblx0XHRpZiAocG9wdGlvbnMub3BhY2l0eSkgeyBzdHlsZS5maWxsT3BhY2l0eSA9IHBvcHRpb25zLm9wYWNpdHk7IH1cblx0XHRlbCA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnSWNvblN0eWxlJyk7XG5cdFx0aWYgKGVsICYmIGVsWzBdKSB7IGlvcHRpb25zID0gX3BhcnNlKGVsWzBdKTsgfVxuXHRcdGlmIChpb3B0aW9ucy5ocmVmKSB7XG5cdFx0XHRzdHlsZS5pY29uID0gbmV3IEwuS01MSWNvbih7XG5cdFx0XHRcdGljb25Vcmw6IGlvcHRpb25zLmhyZWYsXG5cdFx0XHRcdHNoYWRvd1VybDogbnVsbCxcblx0XHRcdFx0YW5jaG9yUmVmOiB7eDogaW9wdGlvbnMueCwgeTogaW9wdGlvbnMueX0sXG5cdFx0XHRcdGFuY2hvclR5cGU6XHR7eDogaW9wdGlvbnMueHVuaXRzLCB5OiBpb3B0aW9ucy55dW5pdHN9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZCA9IHhtbC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cdFx0aWYgKGlkICYmIHN0eWxlKSB7XG5cdFx0XHRzdHlsZS5pZCA9IGlkO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHlsZTtcblx0fSxcblxuXHRwYXJzZVN0eWxlTWFwOiBmdW5jdGlvbiAoeG1sLCBleGlzdGluZ1N0eWxlcykge1xuXHRcdHZhciBzbCA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnU3R5bGVNYXAnKTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2wubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBlID0gc2xbaV0sIGVsO1xuXHRcdFx0dmFyIHNtS2V5LCBzbVN0eWxlVXJsO1xuXG5cdFx0XHRlbCA9IGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2tleScpO1xuXHRcdFx0aWYgKGVsICYmIGVsWzBdKSB7IHNtS2V5ID0gZWxbMF0udGV4dENvbnRlbnQ7IH1cblx0XHRcdGVsID0gZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3R5bGVVcmwnKTtcblx0XHRcdGlmIChlbCAmJiBlbFswXSkgeyBzbVN0eWxlVXJsID0gZWxbMF0udGV4dENvbnRlbnQ7IH1cblxuXHRcdFx0aWYgKHNtS2V5ID09PSAnbm9ybWFsJylcblx0XHRcdHtcblx0XHRcdFx0ZXhpc3RpbmdTdHlsZXNbJyMnICsgZS5nZXRBdHRyaWJ1dGUoJ2lkJyldID0gZXhpc3RpbmdTdHlsZXNbc21TdHlsZVVybF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuO1xuXHR9LFxuXG5cdHBhcnNlRm9sZGVyOiBmdW5jdGlvbiAoeG1sLCBzdHlsZSkge1xuXHRcdHZhciBlbCwgbGF5ZXJzID0gW10sIGw7XG5cdFx0ZWwgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0ZvbGRlcicpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWwubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICghdGhpcy5fY2hlY2tfZm9sZGVyKGVsW2ldLCB4bWwpKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRsID0gdGhpcy5wYXJzZUZvbGRlcihlbFtpXSwgc3R5bGUpO1xuXHRcdFx0aWYgKGwpIHsgbGF5ZXJzLnB1c2gobCk7IH1cblx0XHR9XG5cdFx0ZWwgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1BsYWNlbWFyaycpO1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgZWwubGVuZ3RoOyBqKyspIHtcblx0XHRcdGlmICghdGhpcy5fY2hlY2tfZm9sZGVyKGVsW2pdLCB4bWwpKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRsID0gdGhpcy5wYXJzZVBsYWNlbWFyayhlbFtqXSwgeG1sLCBzdHlsZSk7XG5cdFx0XHRpZiAobCkgeyBsYXllcnMucHVzaChsKTsgfVxuXHRcdH1cblx0XHRlbCA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnR3JvdW5kT3ZlcmxheScpO1xuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZWwubGVuZ3RoOyBrKyspIHtcblx0XHRcdGlmICghdGhpcy5fY2hlY2tfZm9sZGVyKGVsW2tdLCB4bWwpKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRsID0gdGhpcy5wYXJzZUdyb3VuZE92ZXJsYXkoZWxba10pO1xuXHRcdFx0aWYgKGwpIHsgbGF5ZXJzLnB1c2gobCk7IH1cblx0XHR9XG5cdFx0aWYgKCFsYXllcnMubGVuZ3RoKSB7IHJldHVybjsgfVxuXHRcdGlmIChsYXllcnMubGVuZ3RoID09PSAxKSB7IHJldHVybiBsYXllcnNbMF07IH1cblx0XHRyZXR1cm4gbmV3IEwuRmVhdHVyZUdyb3VwKGxheWVycyk7XG5cdH0sXG5cblx0cGFyc2VQbGFjZW1hcms6IGZ1bmN0aW9uIChwbGFjZSwgeG1sLCBzdHlsZSwgb3B0aW9ucykge1xuXHRcdHZhciBoLCBpLCBqLCBrLCBlbCwgaWwsIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0ZWwgPSBwbGFjZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3R5bGVVcmwnKTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgZWwubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB1cmwgPSBlbFtpXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZTtcblx0XHRcdGZvciAodmFyIGEgaW4gc3R5bGVbdXJsXSkge1xuXHRcdFx0XHRvcHRzW2FdID0gc3R5bGVbdXJsXVthXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpbCA9IHBsYWNlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdTdHlsZScpWzBdO1xuXHRcdGlmIChpbCkge1xuXHRcdFx0dmFyIGlubGluZVN0eWxlID0gdGhpcy5wYXJzZVN0eWxlKHBsYWNlKTtcblx0XHRcdGlmIChpbmxpbmVTdHlsZSkge1xuXHRcdFx0XHRmb3IgKGsgaW4gaW5saW5lU3R5bGUpIHtcblx0XHRcdFx0XHRvcHRzW2tdID0gaW5saW5lU3R5bGVba107XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgbXVsdGkgPSBbJ011bHRpR2VvbWV0cnknLCAnTXVsdGlUcmFjaycsICdneDpNdWx0aVRyYWNrJ107XG5cdFx0Zm9yIChoIGluIG11bHRpKSB7XG5cdFx0XHRlbCA9IHBsYWNlLmdldEVsZW1lbnRzQnlUYWdOYW1lKG11bHRpW2hdKTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBlbC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5wYXJzZVBsYWNlbWFyayhlbFtpXSwgeG1sLCBzdHlsZSwgb3B0cyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGxheWVycyA9IFtdO1xuXG5cdFx0dmFyIHBhcnNlID0gWydMaW5lU3RyaW5nJywgJ1BvbHlnb24nLCAnUG9pbnQnLCAnVHJhY2snLCAnZ3g6VHJhY2snXTtcblx0XHRmb3IgKGogaW4gcGFyc2UpIHtcblx0XHRcdHZhciB0YWcgPSBwYXJzZVtqXTtcblx0XHRcdGVsID0gcGxhY2UuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBlbC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgbCA9IHRoaXNbJ3BhcnNlJyArIHRhZy5yZXBsYWNlKC9neDovLCAnJyldKGVsW2ldLCB4bWwsIG9wdHMpO1xuXHRcdFx0XHRpZiAobCkgeyBsYXllcnMucHVzaChsKTsgfVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghbGF5ZXJzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgbGF5ZXIgPSBsYXllcnNbMF07XG5cdFx0aWYgKGxheWVycy5sZW5ndGggPiAxKSB7XG5cdFx0XHRsYXllciA9IG5ldyBMLkZlYXR1cmVHcm91cChsYXllcnMpO1xuXHRcdH1cblxuXHRcdHZhciBuYW1lLCBkZXNjciA9ICcnO1xuXHRcdGVsID0gcGxhY2UuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ25hbWUnKTtcblx0XHRpZiAoZWwubGVuZ3RoICYmIGVsWzBdLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRuYW1lID0gZWxbMF0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWU7XG5cdFx0fVxuXHRcdGVsID0gcGxhY2UuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Rlc2NyaXB0aW9uJyk7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGVsLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgZWxbaV0uY2hpbGROb2Rlcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkZXNjciA9IGRlc2NyICsgZWxbaV0uY2hpbGROb2Rlc1tqXS5ub2RlVmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG5hbWUpIHtcblx0XHRcdGxheWVyLm9uKCdhZGQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGxheWVyLmJpbmRQb3B1cCgnPGgyPicgKyBuYW1lICsgJzwvaDI+JyArIGRlc2NyLCB7IGNsYXNzTmFtZTogJ2ttbC1wb3B1cCd9KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBsYXllcjtcblx0fSxcblxuXHRwYXJzZUNvb3JkczogZnVuY3Rpb24gKHhtbCkge1xuXHRcdHZhciBlbCA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY29vcmRpbmF0ZXMnKTtcblx0XHRyZXR1cm4gdGhpcy5fcmVhZF9jb29yZHMoZWxbMF0pO1xuXHR9LFxuXG5cdHBhcnNlTGluZVN0cmluZzogZnVuY3Rpb24gKGxpbmUsIHhtbCwgb3B0aW9ucykge1xuXHRcdHZhciBjb29yZHMgPSB0aGlzLnBhcnNlQ29vcmRzKGxpbmUpO1xuXHRcdGlmICghY29vcmRzLmxlbmd0aCkgeyByZXR1cm47IH1cblx0XHRyZXR1cm4gbmV3IEwuUG9seWxpbmUoY29vcmRzLCBvcHRpb25zKTtcblx0fSxcblxuXHRwYXJzZVRyYWNrOiBmdW5jdGlvbiAobGluZSwgeG1sLCBvcHRpb25zKSB7XG5cdFx0dmFyIGVsID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdneDpjb29yZCcpO1xuXHRcdGlmIChlbC5sZW5ndGggPT09IDApIHsgZWwgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Nvb3JkJyk7IH1cblx0XHR2YXIgY29vcmRzID0gW107XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBlbC5sZW5ndGg7IGorKykge1xuXHRcdFx0Y29vcmRzID0gY29vcmRzLmNvbmNhdCh0aGlzLl9yZWFkX2d4Y29vcmRzKGVsW2pdKSk7XG5cdFx0fVxuXHRcdGlmICghY29vcmRzLmxlbmd0aCkgeyByZXR1cm47IH1cblx0XHRyZXR1cm4gbmV3IEwuUG9seWxpbmUoY29vcmRzLCBvcHRpb25zKTtcblx0fSxcblxuXHRwYXJzZVBvaW50OiBmdW5jdGlvbiAobGluZSwgeG1sLCBvcHRpb25zKSB7XG5cdFx0dmFyIGVsID0gbGluZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY29vcmRpbmF0ZXMnKTtcblx0XHRpZiAoIWVsLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgbGwgPSBlbFswXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZS5zcGxpdCgnLCcpO1xuXHRcdHJldHVybiBuZXcgTC5LTUxNYXJrZXIobmV3IEwuTGF0TG5nKGxsWzFdLCBsbFswXSksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdHBhcnNlUG9seWdvbjogZnVuY3Rpb24gKGxpbmUsIHhtbCwgb3B0aW9ucykge1xuXHRcdHZhciBlbCwgcG9seXMgPSBbXSwgaW5uZXIgPSBbXSwgaSwgY29vcmRzO1xuXHRcdGVsID0gbGluZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnb3V0ZXJCb3VuZGFyeUlzJyk7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGVsLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb29yZHMgPSB0aGlzLnBhcnNlQ29vcmRzKGVsW2ldKTtcblx0XHRcdGlmIChjb29yZHMpIHtcblx0XHRcdFx0cG9seXMucHVzaChjb29yZHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbCA9IGxpbmUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lubmVyQm91bmRhcnlJcycpO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBlbC5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29vcmRzID0gdGhpcy5wYXJzZUNvb3JkcyhlbFtpXSk7XG5cdFx0XHRpZiAoY29vcmRzKSB7XG5cdFx0XHRcdGlubmVyLnB1c2goY29vcmRzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFwb2x5cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuZmlsbENvbG9yKSB7XG5cdFx0XHRvcHRpb25zLmZpbGwgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAocG9seXMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9seWdvbihwb2x5cy5jb25jYXQoaW5uZXIpLCBvcHRpb25zKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBMLk11bHRpUG9seWdvbihwb2x5cywgb3B0aW9ucyk7XG5cdH0sXG5cblx0Z2V0TGF0TG5nczogZnVuY3Rpb24gKHhtbCkge1xuXHRcdHZhciBlbCA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY29vcmRpbmF0ZXMnKTtcblx0XHR2YXIgY29vcmRzID0gW107XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBlbC5sZW5ndGg7IGorKykge1xuXHRcdFx0Ly8gdGV4dCBtaWdodCBzcGFuIG1hbnkgY2hpbGROb2Rlc1xuXHRcdFx0Y29vcmRzID0gY29vcmRzLmNvbmNhdCh0aGlzLl9yZWFkX2Nvb3JkcyhlbFtqXSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9LFxuXG5cdF9yZWFkX2Nvb3JkczogZnVuY3Rpb24gKGVsKSB7XG5cdFx0dmFyIHRleHQgPSAnJywgY29vcmRzID0gW10sIGk7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGVsLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRleHQgPSB0ZXh0ICsgZWwuY2hpbGROb2Rlc1tpXS5ub2RlVmFsdWU7XG5cdFx0fVxuXHRcdHRleHQgPSB0ZXh0LnNwbGl0KC9bXFxzXFxuXSsvKTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGxsID0gdGV4dFtpXS5zcGxpdCgnLCcpO1xuXHRcdFx0aWYgKGxsLmxlbmd0aCA8IDIpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRjb29yZHMucHVzaChuZXcgTC5MYXRMbmcobGxbMV0sIGxsWzBdKSk7XG5cdFx0fVxuXHRcdHJldHVybiBjb29yZHM7XG5cdH0sXG5cblx0X3JlYWRfZ3hjb29yZHM6IGZ1bmN0aW9uIChlbCkge1xuXHRcdHZhciB0ZXh0ID0gJycsIGNvb3JkcyA9IFtdO1xuXHRcdHRleHQgPSBlbC5maXJzdENoaWxkLm5vZGVWYWx1ZS5zcGxpdCgnICcpO1xuXHRcdGNvb3Jkcy5wdXNoKG5ldyBMLkxhdExuZyh0ZXh0WzFdLCB0ZXh0WzBdKSk7XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fSxcblxuXHRwYXJzZUdyb3VuZE92ZXJsYXk6IGZ1bmN0aW9uICh4bWwpIHtcblx0XHR2YXIgbGF0bG9uYm94ID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdMYXRMb25Cb3gnKVswXTtcblx0XHR2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKFxuXHRcdFx0W1xuXHRcdFx0XHRsYXRsb25ib3guZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NvdXRoJylbMF0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUsXG5cdFx0XHRcdGxhdGxvbmJveC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnd2VzdCcpWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlXG5cdFx0XHRdLFxuXHRcdFx0W1xuXHRcdFx0XHRsYXRsb25ib3guZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ25vcnRoJylbMF0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUsXG5cdFx0XHRcdGxhdGxvbmJveC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZWFzdCcpWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlXG5cdFx0XHRdXG5cdFx0KTtcblx0XHR2YXIgYXR0cmlidXRlcyA9IHtJY29uOiB0cnVlLCBocmVmOiB0cnVlLCBjb2xvcjogdHJ1ZX07XG5cdFx0ZnVuY3Rpb24gX3BhcnNlICh4bWwpIHtcblx0XHRcdHZhciBvcHRpb25zID0ge30sIGlvcHRpb25zID0ge307XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBlID0geG1sLmNoaWxkTm9kZXNbaV07XG5cdFx0XHRcdHZhciBrZXkgPSBlLnRhZ05hbWU7XG5cdFx0XHRcdGlmICghYXR0cmlidXRlc1trZXldKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcdHZhciB2YWx1ZSA9IGUuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWU7XG5cdFx0XHRcdGlmIChrZXkgPT09ICdJY29uJykge1xuXHRcdFx0XHRcdGlvcHRpb25zID0gX3BhcnNlKGUpO1xuXHRcdFx0XHRcdGlmIChpb3B0aW9ucy5ocmVmKSB7IG9wdGlvbnMuaHJlZiA9IGlvcHRpb25zLmhyZWY7IH1cblx0XHRcdFx0fSBlbHNlIGlmIChrZXkgPT09ICdocmVmJykge1xuXHRcdFx0XHRcdG9wdGlvbnMuaHJlZiA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ2NvbG9yJykge1xuXHRcdFx0XHRcdG9wdGlvbnMub3BhY2l0eSA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZygwLCAyKSwgMTYpIC8gMjU1LjA7XG5cdFx0XHRcdFx0b3B0aW9ucy5jb2xvciA9ICcjJyArIHZhbHVlLnN1YnN0cmluZyg2LCA4KSArIHZhbHVlLnN1YnN0cmluZyg0LCA2KSArIHZhbHVlLnN1YnN0cmluZygyLCA0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9wdGlvbnM7XG5cdFx0fVxuXHRcdHZhciBvcHRpb25zID0ge307XG5cdFx0b3B0aW9ucyA9IF9wYXJzZSh4bWwpO1xuXHRcdGlmIChsYXRsb25ib3guZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3JvdGF0aW9uJylbMF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dmFyIHJvdGF0aW9uID0gbGF0bG9uYm94LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdyb3RhdGlvbicpWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlO1xuXHRcdFx0b3B0aW9ucy5yb3RhdGlvbiA9IHBhcnNlRmxvYXQocm90YXRpb24pO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IEwuUm90YXRlZEltYWdlT3ZlcmxheShvcHRpb25zLmhyZWYsIGJvdW5kcywge29wYWNpdHk6IG9wdGlvbnMub3BhY2l0eSwgYW5nbGU6IG9wdGlvbnMucm90YXRpb259KTtcblx0fVxuXG59KTtcblxuTC5LTUxJY29uID0gTC5JY29uLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHRpY29uU2l6ZTogWzMyLCAzMl0sXG5cdFx0aWNvbkFuY2hvcjogWzE2LCAxNl0sXG5cdH0sXG5cdF9zZXRJY29uU3R5bGVzOiBmdW5jdGlvbiAoaW1nLCBuYW1lKSB7XG5cdFx0TC5JY29uLnByb3RvdHlwZS5fc2V0SWNvblN0eWxlcy5hcHBseSh0aGlzLCBbaW1nLCBuYW1lXSk7XG5cdFx0aWYoIGltZy5jb21wbGV0ZSApIHtcblx0XHRcdHRoaXMuYXBwbHlDdXN0b21TdHlsZXMoIGltZyApXG5cdFx0fSBlbHNlIHtcblx0XHRcdGltZy5vbmxvYWQgPSB0aGlzLmFwcGx5Q3VzdG9tU3R5bGVzLmJpbmQodGhpcyxpbWcpXG5cdFx0fVxuXG5cdH0sXG5cdGFwcGx5Q3VzdG9tU3R5bGVzOiBmdW5jdGlvbihpbWcpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHR0aGlzLm9wdGlvbnMucG9wdXBBbmNob3IgPSBbMCwoLTAuODMqaW1nLmhlaWdodCldO1xuXHRcdGlmIChvcHRpb25zLmFuY2hvclR5cGUueCA9PT0gJ2ZyYWN0aW9uJylcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1vcHRpb25zLmFuY2hvclJlZi54ICogaW1nLndpZHRoKSArICdweCc7XG5cdFx0aWYgKG9wdGlvbnMuYW5jaG9yVHlwZS55ID09PSAnZnJhY3Rpb24nKVxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoKC0oMSAtIG9wdGlvbnMuYW5jaG9yUmVmLnkpICogaW1nLmhlaWdodCkgKyAxKSArICdweCc7XG5cdFx0aWYgKG9wdGlvbnMuYW5jaG9yVHlwZS54ID09PSAncGl4ZWxzJylcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1vcHRpb25zLmFuY2hvclJlZi54KSArICdweCc7XG5cdFx0aWYgKG9wdGlvbnMuYW5jaG9yVHlwZS55ID09PSAncGl4ZWxzJylcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5Ub3AgID0gKG9wdGlvbnMuYW5jaG9yUmVmLnkgLSBpbWcuaGVpZ2h0ICsgMSkgKyAncHgnO1xuXHR9XG59KTtcblxuXG5MLktNTE1hcmtlciA9IEwuTWFya2VyLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHRpY29uOiBuZXcgTC5LTUxJY29uLkRlZmF1bHQoKVxuXHR9XG59KTtcblxuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2JiZWNxdWV0L0xlYWZsZXQuUG9seWxpbmVEZWNvcmF0b3IvdHJlZS9tYXN0ZXIvc3JjXG5MLlJvdGF0ZWRJbWFnZU92ZXJsYXkgPSBMLkltYWdlT3ZlcmxheS5leHRlbmQoe1xuXHRvcHRpb25zOiB7XG5cdFx0YW5nbGU6IDBcblx0fSxcblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5JbWFnZU92ZXJsYXkucHJvdG90eXBlLl9yZXNldC5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuX3JvdGF0ZSgpO1xuXHR9LFxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0TC5JbWFnZU92ZXJsYXkucHJvdG90eXBlLl9hbmltYXRlWm9vbS5jYWxsKHRoaXMsIGUpO1xuXHRcdHRoaXMuX3JvdGF0ZSgpO1xuXHR9LFxuXHRfcm90YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChMLkRvbVV0aWwuVFJBTlNGT1JNKSB7XG4gICAgICAgICAgICAvLyB1c2UgdGhlIENTUyB0cmFuc2Zvcm0gcnVsZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlLnN0eWxlW0wuRG9tVXRpbC5UUkFOU0ZPUk1dICs9ICcgcm90YXRlKCcgKyB0aGlzLm9wdGlvbnMuYW5nbGUgKyAnZGVnKSc7XG4gICAgICAgIH0gZWxzZSBpZiAoTC5Ccm93c2VyLmllKSB7XG4gICAgICAgICAgICAvLyBmYWxsYmFjayBmb3IgSUU2LCBJRTcsIElFOFxuICAgICAgICAgICAgdmFyIHJhZCA9IHRoaXMub3B0aW9ucy5hbmdsZSAqIChNYXRoLlBJIC8gMTgwKSxcbiAgICAgICAgICAgICAgICBjb3N0aGV0YSA9IE1hdGguY29zKHJhZCksXG4gICAgICAgICAgICAgICAgc2ludGhldGEgPSBNYXRoLnNpbihyYWQpO1xuICAgICAgICAgICAgdGhpcy5faW1hZ2Uuc3R5bGUuZmlsdGVyICs9ICcgcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChzaXppbmdNZXRob2Q9XFwnYXV0byBleHBhbmRcXCcsIE0xMT0nICtcbiAgICAgICAgICAgICAgICBjb3N0aGV0YSArICcsIE0xMj0nICsgKC1zaW50aGV0YSkgKyAnLCBNMjE9JyArIHNpbnRoZXRhICsgJywgTTIyPScgKyBjb3N0aGV0YSArICcpJztcbiAgICAgICAgfVxuXHR9LFxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuXHR9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/leaflet-kml/L.KML.js\n"));

/***/ }),

/***/ "./components/constructions/surface/map.tsx":
/*!**************************************************!*\
  !*** ./components/constructions/surface/map.tsx ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Map; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_src_sliced_to_array_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/src/_sliced_to_array.mjs */ \"./node_modules/@swc/helpers/src/_sliced_to_array.mjs\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leaflet/dist/leaflet.css */ \"./node_modules/leaflet/dist/leaflet.css\");\n/* harmony import */ var leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(leaflet_dist_leaflet_css__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_leaflet__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-leaflet */ \"./node_modules/react-leaflet/lib/index.js\");\n/* harmony import */ var react_leaflet_kml__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-leaflet-kml */ \"./node_modules/react-leaflet-kml/lib/index.js\");\n/* harmony import */ var react_leaflet_kml__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_leaflet_kml__WEBPACK_IMPORTED_MODULE_3__);\n\n\nvar _s = $RefreshSig$();\n\n\n\n\nfunction Map() {\n    _s();\n    var center = [\n        15.023683,\n        108.662813\n    ];\n    var ref = (0,_swc_helpers_src_sliced_to_array_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(react__WEBPACK_IMPORTED_MODULE_1__.useState(null), 2), kml = ref[0], setKml = ref[1];\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(function() {\n        fetch(\"/kml/song.kml\").then(function(res) {\n            return res.text();\n        }).then(function(kmlText) {\n            var parser = new DOMParser();\n            var kml = parser.parseFromString(kmlText, \"text/xml\");\n            setKml(kml);\n        });\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_leaflet__WEBPACK_IMPORTED_MODULE_5__.MapContainer, {\n        center: center,\n        zoom: 9,\n        style: {\n            height: \"50vh\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_leaflet__WEBPACK_IMPORTED_MODULE_5__.TileLayer, {\n                attribution: '\\xa9 <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors',\n                url: \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n            }, void 0, false, {\n                fileName: \"/Users/lover/Documents/GitHub/wr-nb/components/constructions/surface/map.tsx\",\n                lineNumber: 26,\n                columnNumber: 7\n            }, this),\n            kml && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((react_leaflet_kml__WEBPACK_IMPORTED_MODULE_3___default()), {\n                kml: kml\n            }, void 0, false, {\n                fileName: \"/Users/lover/Documents/GitHub/wr-nb/components/constructions/surface/map.tsx\",\n                lineNumber: 30,\n                columnNumber: 15\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/lover/Documents/GitHub/wr-nb/components/constructions/surface/map.tsx\",\n        lineNumber: 25,\n        columnNumber: 5\n    }, this);\n};\n_s(Map, \"wdCNrsrUD3dX3ej31c5nO/j18eU=\");\n_c = Map;\nvar _c;\n$RefreshReg$(_c, \"Map\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL2NvbnN0cnVjdGlvbnMvc3VyZmFjZS9tYXAudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztBQUErQjtBQUNHO0FBQ3NDO0FBQ3hCO0FBR2pDLFNBQVNJLEdBQUcsR0FBRzs7SUFDNUIsSUFBTUMsTUFBTSxHQUFHO0FBQUMsaUJBQVM7QUFBRSxrQkFBVTtLQUFDO0lBRXRDLElBQXNCTCxHQUFvQixvRkFBcEJBLDJDQUFjLENBQUMsSUFBSSxDQUFDLE1BQW5DTyxHQUFHLEdBQVlQLEdBQW9CLEdBQWhDLEVBQUVRLE1BQU0sR0FBSVIsR0FBb0IsR0FBeEI7SUFFbEJBLDRDQUFlLENBQUMsV0FBTTtRQUNwQlUsS0FBSyxDQUNILGVBQWUsQ0FDaEIsQ0FDRUMsSUFBSSxDQUFDLFNBQUNDLEdBQUc7bUJBQUtBLEdBQUcsQ0FBQ0MsSUFBSSxFQUFFO1NBQUEsQ0FBQyxDQUN6QkYsSUFBSSxDQUFDLFNBQUNHLE9BQU8sRUFBSztZQUNqQixJQUFNQyxNQUFNLEdBQUcsSUFBSUMsU0FBUyxFQUFFO1lBQzlCLElBQU1ULEdBQUcsR0FBR1EsTUFBTSxDQUFDRSxlQUFlLENBQUNILE9BQU8sRUFBRSxVQUFVLENBQUM7WUFDdkROLE1BQU0sQ0FBQ0QsR0FBRyxDQUFDLENBQUM7UUFDZCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUVQLHFCQUNFLDhEQUFDTix1REFBWTtRQUFDSSxNQUFNLEVBQUVBLE1BQU07UUFBRWEsSUFBSSxFQUFFLENBQUM7UUFBRUMsS0FBSyxFQUFFO1lBQUVDLE1BQU0sRUFBRSxNQUFNO1NBQUU7OzBCQUM5RCw4REFBQ2xCLG9EQUFTO2dCQUNSbUIsV0FBVyxFQUFDLHdFQUEwRTtnQkFDdEZDLEdBQUcsRUFBQyxvREFBb0Q7Ozs7O29CQUN4RDtZQUNEZixHQUFHLGtCQUFJLDhEQUFDSiwwREFBZTtnQkFBQ0ksR0FBRyxFQUFFQSxHQUFHOzs7OztvQkFBSTs7Ozs7O1lBQ3hCLENBQ2Y7QUFDSixDQUFDO0dBMUJ1QkgsR0FBRztBQUFIQSxLQUFBQSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvY29uc3RydWN0aW9ucy9zdXJmYWNlL21hcC50c3g/ZWI0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAnbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzJztcbmltcG9ydCB7IE1hcENvbnRhaW5lciwgVGlsZUxheWVyLCBNYXJrZXIsIHVzZU1hcCB9IGZyb20gJ3JlYWN0LWxlYWZsZXQnO1xuaW1wb3J0IFJlYWN0TGVhZmxldEttbCBmcm9tICdyZWFjdC1sZWFmbGV0LWttbCc7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFwKCkge1xuICBjb25zdCBjZW50ZXIgPSBbMTUuMDIzNjgzLCAxMDguNjYyODEzXTtcblxuICBjb25zdCBba21sLCBzZXRLbWxdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBmZXRjaChcbiAgICAgIFwiL2ttbC9zb25nLmttbFwiXG4gICAgKVxuICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLnRleHQoKSlcbiAgICAgIC50aGVuKChrbWxUZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgY29uc3Qga21sID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhrbWxUZXh0LCBcInRleHQveG1sXCIpO1xuICAgICAgICBzZXRLbWwoa21sKTtcbiAgICAgIH0pO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8TWFwQ29udGFpbmVyIGNlbnRlcj17Y2VudGVyfSB6b29tPXs5fSBzdHlsZT17eyBoZWlnaHQ6ICc1MHZoJyB9fT5cbiAgICAgIDxUaWxlTGF5ZXJcbiAgICAgICAgYXR0cmlidXRpb249JyZjb3B5OyA8YSBocmVmPVwiaHR0cDovL29zbS5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzJ1xuICAgICAgICB1cmw9XCJodHRwczovL3tzfS50aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZ1wiXG4gICAgICAvPlxuICAgICAge2ttbCAmJiA8UmVhY3RMZWFmbGV0S21sIGttbD17a21sfSAvPn1cbiAgICA8L01hcENvbnRhaW5lcj5cbiAgKTtcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJNYXBDb250YWluZXIiLCJUaWxlTGF5ZXIiLCJSZWFjdExlYWZsZXRLbWwiLCJNYXAiLCJjZW50ZXIiLCJ1c2VTdGF0ZSIsImttbCIsInNldEttbCIsInVzZUVmZmVjdCIsImZldGNoIiwidGhlbiIsInJlcyIsInRleHQiLCJrbWxUZXh0IiwicGFyc2VyIiwiRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwiem9vbSIsInN0eWxlIiwiaGVpZ2h0IiwiYXR0cmlidXRpb24iLCJ1cmwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/constructions/surface/map.tsx\n"));

/***/ }),

/***/ "./node_modules/react-leaflet-kml/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-leaflet-kml/lib/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n// @ts-ignore\r\n__webpack_require__(/*! leaflet-kml */ \"./node_modules/leaflet-kml/L.KML.js\");\r\nvar L = __importStar(__webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\"));\r\nvar core_1 = __webpack_require__(/*! @react-leaflet/core */ \"./node_modules/@react-leaflet/core/lib/index.js\");\r\nvar updateOnCanvas = function (map) {\r\n    if (map.options.preferCanvas) {\r\n        // @ts-ignore  \r\n        map._renderer._update();\r\n    }\r\n};\r\nvar createLeafletElement = function (props, context) {\r\n    var kml = props.kml, kmlOptions = props.kmlOptions;\r\n    // @ts-ignore\r\n    var instance = new L.KML(kml, kmlOptions);\r\n    if (context.map.options.preferCanvas) {\r\n        setTimeout(function (map) {\r\n            // Handling react-leaflet bug of canvas renderer not updating\r\n            // @ts-ignore\r\n            map._renderer._update();\r\n        }, 0, context.map);\r\n    }\r\n    return { instance: instance, context: context };\r\n};\r\nvar updateLeafletElement = function (instance, props, prevProps) {\r\n    // @ts-ignore\r\n    updateOnCanvas(instance._map);\r\n};\r\nexports[\"default\"] = (0, core_1.createLayerComponent)(createLeafletElement, updateLeafletElement);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtbGVhZmxldC1rbWwvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBLG1CQUFPLENBQUMsd0RBQWE7QUFDckIscUJBQXFCLG1CQUFPLENBQUMsMkRBQVM7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLDRFQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1sZWFmbGV0LWttbC9saWIvaW5kZXguanM/YzBkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn0pO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyBAdHMtaWdub3JlXHJcbnJlcXVpcmUoXCJsZWFmbGV0LWttbFwiKTtcclxudmFyIEwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImxlYWZsZXRcIikpO1xyXG52YXIgY29yZV8xID0gcmVxdWlyZShcIkByZWFjdC1sZWFmbGV0L2NvcmVcIik7XHJcbnZhciB1cGRhdGVPbkNhbnZhcyA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgIGlmIChtYXAub3B0aW9ucy5wcmVmZXJDYW52YXMpIHtcclxuICAgICAgICAvLyBAdHMtaWdub3JlICBcclxuICAgICAgICBtYXAuX3JlbmRlcmVyLl91cGRhdGUoKTtcclxuICAgIH1cclxufTtcclxudmFyIGNyZWF0ZUxlYWZsZXRFbGVtZW50ID0gZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0KSB7XHJcbiAgICB2YXIga21sID0gcHJvcHMua21sLCBrbWxPcHRpb25zID0gcHJvcHMua21sT3B0aW9ucztcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBMLktNTChrbWwsIGttbE9wdGlvbnMpO1xyXG4gICAgaWYgKGNvbnRleHQubWFwLm9wdGlvbnMucHJlZmVyQ2FudmFzKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAgICAgICAgIC8vIEhhbmRsaW5nIHJlYWN0LWxlYWZsZXQgYnVnIG9mIGNhbnZhcyByZW5kZXJlciBub3QgdXBkYXRpbmdcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBtYXAuX3JlbmRlcmVyLl91cGRhdGUoKTtcclxuICAgICAgICB9LCAwLCBjb250ZXh0Lm1hcCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBpbnN0YW5jZTogaW5zdGFuY2UsIGNvbnRleHQ6IGNvbnRleHQgfTtcclxufTtcclxudmFyIHVwZGF0ZUxlYWZsZXRFbGVtZW50ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBwcm9wcywgcHJldlByb3BzKSB7XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICB1cGRhdGVPbkNhbnZhcyhpbnN0YW5jZS5fbWFwKTtcclxufTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIGNvcmVfMS5jcmVhdGVMYXllckNvbXBvbmVudCkoY3JlYXRlTGVhZmxldEVsZW1lbnQsIHVwZGF0ZUxlYWZsZXRFbGVtZW50KTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-leaflet-kml/lib/index.js\n"));

/***/ })

});